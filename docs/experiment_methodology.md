# A1实验：压缩比与序列化开销 - 实验方法与环境描述

## 1. 实验目的

本实验旨在通过软件模拟的方式，评估RDMA元数据压缩方案中Token序列化（encode）和反序列化（decode）操作的性能特征，具体目标包括：

1. **压缩比验证**：验证各类Token（PD、MR、CQ、QP）的真实字节大小，计算压缩后相对于原始结构体的压缩比
2. **序列化开销测量**：量化encode和decode操作的延迟和吞吐量，评估其对系统性能的影响
3. **可扩展性分析**：分析不同数据规模（N值）对序列化性能的影响，识别性能瓶颈
4. **性能差异分析**：深入理解encode和decode操作性能差异的根本原因，为系统优化提供依据

## 2. 实验环境

### 2.1 硬件平台

**测试平台：**
- **CPU架构**：x86_64
- **处理器型号**：[具体型号，如Intel Core i7-xxx或AMD Ryzen xxx]
- **CPU核心数**：[具体核心数]
- **CPU频率**：[基础频率和最高频率]
- **缓存层次**：
  - L1数据缓存：32KB/核心
  - L1指令缓存：32KB/核心
  - L2缓存：256KB/核心（或统一缓存）
  - L3缓存：共享，[具体大小]MB
- **内存**：DDR4/DDR5，[具体容量]GB，[频率]MHz
- **操作系统**：Linux [内核版本]

**注：** 由于实验采用纯软件模拟方式，所有性能测量均反映当前硬件平台的实际性能特征。硬件配置的详细信息对于实验的可重复性至关重要。

### 2.2 软件环境

**编译器与构建工具：**
- **编译器**：GCC [版本号] 或 Clang [版本号]
- **C++标准**：C++17
- **编译优化选项**：`-O3 -march=native`
  - `-O3`：启用最高级别的优化
  - `-march=native`：针对当前CPU架构进行优化
- **构建系统**：CMake [版本号]
- **链接库**：标准C++库（libstdc++或libc++）

**操作系统与运行时：**
- **操作系统**：Linux [发行版] [版本号]
- **内核版本**：Linux [内核版本号]
- **CPU调度器**：CFS (Completely Fair Scheduler)
- **CPU频率调节器**：performance模式（确保CPU运行在最高频率）

### 2.3 实验工具

**实验程序：**
- **程序名称**：`exp_a1_compress`
- **编程语言**：C++17
- **依赖库**：仅标准库，无外部依赖
- **可执行文件大小**：约[具体大小]KB
- **内存占用**：根据N值动态分配，最大约[具体大小]MB

## 3. 实验设计

### 3.1 实验方法

本实验采用**微基准测试（Micro-benchmark）**方法，通过精确测量序列化操作的性能指标来评估系统性能。实验设计遵循以下原则：

1. **隔离性**：每个测试用例独立运行，避免相互干扰
2. **可重复性**：每个配置重复执行多次（默认10次），取平均值和95th分位数
3. **准确性**：使用高精度计时器（`std::chrono::high_resolution_clock`）
4. **公平性**：确保encode和decode操作在相同的测试条件下进行

### 3.2 测试工作负载

**Token类型：**
- PD Token（Protection Domain）：8字节
- MR Token（Memory Region）：12字节
- CQ Token（Completion Queue）：12字节
- QP Token（Queue Pair）：16字节

**数据规模（N值）：**
- N = 1,000 tokens
- N = 10,000 tokens
- N = 100,000 tokens
- N = 1,000,000 tokens

**字段分布模式：**
- **随机分布**：使用伪随机数生成器生成Token字段值，模拟真实场景的多样性
- **典型分布**：使用固定模式生成Token字段值，模拟典型应用场景

### 3.3 性能指标

**延迟指标：**
- **平均延迟（avg_latency）**：所有操作的平均延迟（微秒/操作）
- **95th分位数延迟（p95_latency）**：95%的操作延迟小于等于该值

**吞吐量指标：**
- **吞吐量（throughput）**：每秒处理的Token数量（tokens/sec）
  - 计算公式：`throughput = 1,000,000 / avg_latency_us`

**压缩指标：**
- **压缩比（compression_ratio）**：原始结构体大小 / 压缩后字节数
- **每Token字节数（bytes_per_token）**：压缩后平均每个Token的字节数

## 4. 实验实施

### 4.1 实验程序实现细节

**内存布局设计：**
- 使用连续内存缓冲区（`std::vector<uint8_t>`）存储编码后的Token数据
- 避免使用`vector<vector<uint8_t>>`等嵌套结构，消除间接访问开销
- 确保内存对齐，避免缓存行跨界的性能损失

**测量方法：**
```cpp
// Encode测量：只测量memcpy操作，不包含内存分配
auto t0 = std::chrono::high_resolution_clock::now();
for (size_t i = 0; i < N; i++) {
    std::memcpy(encoded_buffer.data() + offsets[i], &tokens[i], tokens[i].size());
}
auto t1 = std::chrono::high_resolution_clock::now();
double enc_us = std::chrono::duration<double, std::micro>(t1 - t0).count();

// Decode测量：包含预热，确保缓存已加载
// 预热阶段（不测量）
for (size_t i = 0; i < min(N, 1000); i++) {
    std::memcpy(&tmp, encoded_buffer.data() + offsets[i], tokens[i].size());
}
// 正式测量
auto t2 = std::chrono::high_resolution_clock::now();
for (size_t i = 0; i < N; i++) {
    std::memcpy(&tmp, encoded_buffer.data() + offsets[i], tokens[i].size());
}
auto t3 = std::chrono::high_resolution_clock::now();
double dec_us = std::chrono::duration<double, std::micro>(t3 - t2).count();
```

**关键设计决策：**
1. **预热机制**：Decode操作前进行预热，减少首次访问的缓存miss影响
2. **内存连续性**：使用连续内存缓冲区，最大化缓存局部性
3. **精确计时**：使用高分辨率时钟，精度达到纳秒级
4. **多次重复**：每个配置重复10次，计算统计量以减少测量误差

### 4.2 实验执行流程

**步骤1：环境准备**
```bash
# 设置CPU频率为performance模式
sudo cpupower frequency-set -g performance

# 禁用CPU频率缩放
echo performance | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor

# 绑定进程到特定CPU核心（可选，减少调度干扰）
taskset -c 0 ./exp_a1_compress [参数]
```

**步骤2：编译实验程序**
```bash
mkdir build && cd build
cmake -DCMAKE_BUILD_TYPE=Release \
      -DCMAKE_CXX_FLAGS="-O3 -march=native" \
      ..
make exp_a1_compress
```

**步骤3：执行实验**
```bash
./exp_a1_compress \
    --type=QP \
    --N_values=1000,10000,100000,1000000 \
    --iters=10 \
    --random \
    --output=results.json
```

**步骤4：结果验证**
- 检查输出JSON文件格式是否正确
- 验证统计量（平均值、分位数）是否合理
- 对比不同N值下的性能趋势

### 4.3 实验可重复性保证

**环境一致性：**
- 记录完整的硬件配置信息
- 记录软件版本号（编译器、操作系统等）
- 使用相同的编译选项和运行时环境

**测量准确性：**
- 多次重复实验，取平均值和分位数
- 使用统计方法识别异常值
- 报告测量误差和置信区间（如适用）

**可验证性：**
- 实验代码开源，可公开审查
- 提供详细的实验步骤文档
- 实验结果以JSON格式保存，便于后续分析

## 5. 实验局限性说明

### 5.1 软件模拟的局限性

**与真实硬件的差异：**
1. **RDMA硬件特性**：本实验仅测量序列化/反序列化的CPU开销，未考虑RDMA硬件加速的实际性能
2. **网络延迟**：真实RDMA操作涉及网络传输，本实验未包含网络延迟
3. **并发场景**：本实验采用单线程顺序执行，未考虑多线程并发场景
4. **系统调用开销**：真实场景可能涉及系统调用和内核态切换，本实验在用户态执行

**硬件平台依赖性：**
- 实验结果与具体硬件平台（CPU、缓存、内存）密切相关
- 不同硬件平台的结果可能差异较大
- 实验结果主要反映当前硬件平台的性能特征

### 5.2 测量方法的局限性

**计时精度：**
- 虽然使用高分辨率时钟，但仍受CPU频率变化和系统调度影响
- 对于极短的操作（<1微秒），测量误差可能相对较大

**缓存影响：**
- 即使进行预热，首次运行和后续运行的结果可能仍有差异
- 不同N值下的缓存行为可能不同，影响结果比较

**编译器优化：**
- 高优化级别（-O3）可能对代码进行激进优化，改变实际执行路径
- 某些优化可能消除或改变测量目标的操作

## 6. 实验结果有效性

### 6.1 内部有效性

**控制变量：**
- 所有实验使用相同的编译选项和运行时环境
- Encode和Decode操作在相同的测试条件下进行
- 使用相同的测试数据和测量方法

**统计显著性：**
- 每个配置重复10次，提供足够的样本量
- 报告平均值和95th分位数，反映性能分布
- 可以计算置信区间和统计显著性（如需要）

### 6.2 外部有效性

**可推广性：**
- 实验结果反映了现代x86_64 CPU的一般性能特征
- 实验方法可以应用于其他硬件平台
- 实验设计考虑了不同数据规模，具有一定的通用性

**实际应用相关性：**
- 虽然采用软件模拟，但测量的核心操作（memcpy）在真实RDMA系统中同样存在
- 实验结果可以为系统设计和优化提供参考
- 性能差异的根本原因（内存访问模式、缓存效率）在真实系统中同样适用

## 7. 论文中的表述建议

### 7.1 实验目的段落

> "为了评估RDMA元数据压缩方案中Token序列化操作的性能特征，我们设计了A1实验，通过微基准测试方法量化encode和decode操作的延迟和吞吐量。实验采用软件模拟方式，在标准x86_64平台上进行，旨在深入理解序列化操作的性能瓶颈和优化空间。"

### 7.2 实验环境段落

> "实验在配备[具体CPU型号]的Linux系统上执行，使用GCC [版本号]编译器，编译选项为`-O3 -march=native`。为确保测量准确性，CPU频率调节器设置为performance模式，并采用高精度计时器（`std::chrono::high_resolution_clock`）进行测量。每个配置重复执行10次，报告平均值和95th分位数。"

### 7.3 实验方法段落

> "实验采用微基准测试方法，使用连续内存缓冲区存储编码后的Token数据，避免间接访问开销。Encode操作测量从Token结构体到字节流的memcpy延迟，Decode操作在预热后测量从字节流到Token结构体的memcpy延迟。测试数据规模（N值）从1,000到1,000,000，覆盖不同应用场景。为减少测量误差，每个配置重复执行10次，并计算统计量。"

### 7.4 局限性说明段落

> "需要说明的是，本实验采用纯软件模拟方式，仅测量序列化/反序列化的CPU开销，未考虑RDMA硬件加速和网络传输的实际性能。实验结果与具体硬件平台密切相关，主要反映当前测试平台的性能特征。尽管如此，实验测量的核心操作（memcpy）在真实RDMA系统中同样存在，实验结果可以为系统设计和优化提供有价值的参考。"

## 8. 实验数据记录模板

### 8.1 硬件配置记录

```
CPU型号：[具体型号]
CPU核心数：[具体数量]
CPU频率：[基础频率] - [最高频率] GHz
L1缓存：[大小]KB/核心
L2缓存：[大小]KB/核心
L3缓存：[大小]MB（共享）
内存：[容量]GB [类型] [频率]MHz
操作系统：[发行版] [版本号]
内核版本：Linux [版本号]
```

### 8.2 软件配置记录

```
编译器：GCC/Clang [版本号]
C++标准：C++17
编译选项：-O3 -march=native
CMake版本：[版本号]
构建日期：[日期]
```

### 8.3 实验结果记录

实验结果以JSON格式保存，包含：
- 实验配置（Token类型、N值、重复次数）
- 延迟统计（平均值、95th分位数）
- 吞吐量统计
- 压缩比和字节数统计

## 9. 可重现性清单

为确保实验的可重现性，请记录以下信息：

- [ ] 硬件配置详细信息
- [ ] 软件版本号（编译器、操作系统、CMake等）
- [ ] 编译选项和构建命令
- [ ] 运行时环境设置（CPU频率调节器、进程绑定等）
- [ ] 实验参数和配置
- [ ] 实验结果文件（JSON格式）
- [ ] 实验代码版本（Git提交哈希）

---

**注：** 本文档提供的实验描述框架遵循学术论文的标准格式，确保实验方法的可信度和可重现性。在实际使用时，请根据具体硬件平台和实验环境填写详细信息。

